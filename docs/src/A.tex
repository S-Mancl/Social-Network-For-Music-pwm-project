Di seguito saranno spiegate alcune scelte implementative relative a varie sezioni, iniziando da quelle riguardanti la struttura dati nel database.
\subsection{Struttura dati nel database}
TODO TO DO
\subsection{Backend}
\subsubsection{Accesso alle informazioni riservate}
Alcune informazioni non dovevano diventare pubbliche, ossia venire direttamente a contatto (per esempio venendovi inserite) con il frontend.

A questo scopo ho optato per l'utilizzo di un file \verb|.env|, prontamente inserito nel \verb|.gitignore| e che sarà consegnato a fianco della repo, contenente queste informazioni secondo il seguente formato:
\begin{lstlisting}
MONGONAME=XXXXXXXXXXXX
MONGOPASSWORD=XXXXXXXXXXXX
PORT=3000
CLIENT_ID=XXXXXXXXXXXX
CLIENT_SECRET=XXXXXXXXXXXX
SECRET=XXXXXXXXXXXX
\end{lstlisting}
Dove \verb|SECRET| è la chiave per firmare i \verb|JWT|, \verb|MONGONAME| e \verb|MONGOPASSWORD| sono relativi all'utilizzo di MongoDB, \verb|CLIENT_ID| e \verb|CLIENT_SECRET| servono per Spotify e \verb|PORT| può essere usato per cambiare il numero della porta su cui viene esposto il servizio.

Per accedervi viene usato il package \verb|DotEnv|, di cui parlo più approfonditamente nella sezione \verb|tecnologie|.
\subsubsection{JWT nei cookies anziché dati dell'utente nel local storage}
\idea{L'utilizzo dei JWT nei cookies permette di eseguire più facilmente e in modo più sicuro i controlli se l'utente è loggato o meno}
Voglio realizzare una autenticazione lievemente più sicura di quella richiesta. Per ottenere questo scopo utilizzo i JWT (con un apposito package di cui parlerà nella sezione \verb|tecnologie|), firmati con una chiave presente nel file \verb|.env|, e li salvo nei cookie in modo che vengano passati in automatico ad ogni richiesta.

Si avrà quindi il logout nella forma di un \verb|res.clearCookie('token')| e un controllo sull'identità dell'utente mediante un codice come quello che segue:
\begin{lstlisting}
async function nomeMetodo(req,res){
    var pwmClient = await new mongoClient(mongoUrl).connect()
    const token = req.cookies.token
    if(token == undefined) res.status(401).json({"reason": `Invalid login`})
    else{
        jwt.verify(token,process.env.SECRET, async (err,decoded) =>{
            if(err){
                res.status(401).json(err)
                pwmClient.close()
            }
            else{
                //vero e proprio codice del metodo
                pwmClient.close()
            }
        })
    }
}
\end{lstlisting}
\alert{Questo sistema è sempre vulnerabile ad un possibile \say{furto} dei cookie: qualora questi venissero rubati è possibile per un utente inserirsi al posto di un altro, cambiare email e password e rendere impossibile all'utente originario l'accesso. Questo è un problema che non ho risolto in quanto ho ritenuto fuori dalle finalità di questo progetto, tuttavia sono consapevole del problema}
\subsubsection{Token Object e perform function}
La richiesta (per quasi ogni informazione) di un token valido che scade ogni ora per operare con Spotify mi ha fatto optare per la creazione di un oggetto \verb|Token|, come nel seguente brano di codice:
\begin{lstlisting}
var token = {
    value: "none",
    expiration: 42,
    regenAndThen : function(func_to_apply,paramA,paramB){
        fetch(baseUrls.token, {
            method: "POST",
            headers: {
            Authorization: "Basic " + btoa(`${process.env.CLIENT_ID}:${process.env.CLIENT_SECRET}`),
            "Content-Type": "application/x-www-form-urlencoded",
            },
            body: new URLSearchParams({ grant_type: "client_credentials" }),
        })
        .then((response) => response.json())
        .then((tokenResponse) => {
            this.expiration = new Date().getTime(); //ms
            this.value=tokenResponse.access_token
            func_to_apply(paramA,paramB)
        })                   
    },
    hasExpired : function(){
        if(((new Date().getTime()-this.expiration)/1000/60)>=59){
            return true;
        }
        else return false;
    }
}
\end{lstlisting}
Questo oggetto presenta una serie di caratteristiche: esso ha due attributi, \verb|value| che rappresenta il valore corrente del token, all'inizio un valore fasullo, e \verb|expiration| che permette di sapere il momento in cui è stato ottenuto, all'inizio un valore spurio (\verb|42|) così da essere sicuri che al primo uso esso venga ricaricato.

Esso ha inoltre due metodi.
Abbiamo infatti \verb|hasExpired| permette di sapere se sono passati più di (o esattamente) 59 minuti dalla scadenza.

\idea{Ho impostato come tempo limite 59 minuti e non un'ora perché le operazioni richiedono tempo, pertanto un'ora non sarebbe stato utile in quanto avrebbe potuto scadere prima del completamento della richiesta. In questo modo, invece, dovrebbe essere sempre possibile avere dei token validi.}

Vi è poi \verb|regenAndThen| che consiste in un applicatore: esso riceve tre parametri (\verb|func_to_apply|, funzione; \verb|paramA| e \verb|paramB| parametri da passare a quella funzione) ed effettua le seguenti operazioni:

\begin{enumerate}
    \item Rigenera il token
    \item Sostituisce il valore del token e il momento in cui è stato generato a quelli precedenti
    \item Chiama la funzione con i parametri passati
\end{enumerate}
\paragraph{perform} Il token object risulta di gran lunga più pratico nel momento in cui è utilizzato insieme alla funzione \verb|perform|, definita come segue:
\begin{lstlisting}
function perform(questo,paramA,paramB){
    if(token.hasExpired()) token.regenAndThen(questo,paramA,paramB)
    else questo(paramA,paramB)
}
\end{lstlisting}
Questa funzione è ancora una volta un applicatore, in particolare nei confronti del parametro-funzione \verb|questo|. Esso verifica se il token è scaduto sfruttando gli appositi metodi dell'oggetto \verb|token|. In caso sia scaduto chiama l'applicatore \verb|regenAndThen|, altrimenti esegue direttamente, così da non rigenerare il token ad ogni chiamata, ma solo quando necessario.

\newpage